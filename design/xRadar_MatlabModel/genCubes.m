% 
% Copyright (C) 2024, Advanced Micro Devices, Inc. All rights reserved.
% SPDX-License-Identifier: MIT
% 

%% Author Bachir B./Fidus
% xRadar - Phase 2

% Note that this function excutes the simulink model but does NOT open it.
% If you wish to open the model type the command:  open('./Radar/xRadar.slx'),
% prior of running this script. Most of the model parameters can be
% modified in ./Radar/xRadarParam.m;

% Functions/objects called/created:
%  - ./Radar/xRadarParam  (Fidus)
% ------------------------------------------------------------------------

% Function executes the follwing simulink Model
%  - ./Radar/xRadar.slx   (Original by Mathwork, Modified by Fidus)
% - This Function generates X-Radar cuboids. The parameters and number of
%   cuboids are as specified in ./Radar//xRadarParam.m



%% Add Path to Model
clear ;
addpath  ./Radar/

%% Get Sim static parameters, and initialized the distance increments
tDeltaX=0; tDeltaY=0;
rDeltaX=0; rDeltaY=0; rDeltaZ=0;
jDeltaX=0; jDeltaY=0; jDeltaZ=0;

paramSTAP   = xRadarParam(tDeltaX, tDeltaY,          ...
                         rDeltaX, rDeltaY, rDeltaZ,  ...
                         jDeltaX, jDeltaY, jDeltaZ);

N              = paramSTAP.radarAntenna.NumElements;
L              = paramSTAP.samplesPerFrame;
M              = paramSTAP.numPulseInt;
gC             = paramSTAP.guardCells;
tC             = paramSTAP.trainingCells;

rSpeed         = paramSTAP.radarVel;
tSpeed         = paramSTAP.target1Vel;
jSpeed         = paramSTAP.jammerVel;

cpi            = paramSTAP.cpi;
simStep        = paramSTAP.simStep;
nbrSimSteps    = paramSTAP.nbrSimSteps;


%%  Open System Model
fprintf("\n -- <strong>NOTE</strong>: Loading X-Radar System Model.  After the initial load, the model is cached in the current folder (XRadar.slxc) \n");
open_system('xRadar.slx', 'loadonly');

%% ...  run Model, and generates "nbrSimSteps" cuboids'
fprintf("\n -- <strong>NOTE</strong>: The number of simulation steps is set to %d  \n", nbrSimSteps);
fprintf("\n -- <strong>NOTE</strong>: Total compile time depends on size of cuboid and the number of simulation steps \n");
for k=1:nbrSimSteps
    %% run model with increments in position of the radar and the target
    paramSTAP   = xRadarParam(  tDeltaX, tDeltaY,          ...
                                rDeltaX, rDeltaY, rDeltaZ, ...
                                jDeltaX, jDeltaY, jDeltaZ);
    
 
    %% Launch Simulation
    fprintf("\n -- <strong>NOTE</strong>: Compiling and Running the Simulink Model to generate cuboid #%d  \n", k);
    sim('xRadar.slx');
    [s, c] = system('move CPI_Cuboid_Data.mat ./Radar/');
    %% Load the Cuboid generated by the Simulkink model
    xCube  = load('./Radar/CPI_Cuboid_Data.mat');
    xC=squeeze(xCube.Cuboid.Data);
    % Eliminate the 1st noise-filled cuboid
    xC = squeeze(xC(:,:,:,2));
    
    %% Scale and Cast into int16
    cubeS = []; cubeS_fi =[]; cubeS_int16 = [];
    sVal          = max(xC,[],'all');
    cubeS         = single(xC.* (1/(sVal))); % Scaled Cube
    cubeS_fi      = fi(cubeS, 1, 16, 15);
    cubeS_int16   = int16((2^15)*cubeS_fi);
    spCube_int16  = permute(cubeS_int16, [2 1 3] ); % Space Cube 
    
    %% Save cuboids into binary files in I/Q interleaved format
    fprintf("\n -- <strong>NOTE</strong>: Saving Cuboid #%d under ./Cuboids  \n", k);
    spCubeIQ_int16 = int16(zeros(1, 2*N*L*M));
    i = real(reshape(spCube_int16, N*L*M, []));
    q = imag(reshape(spCube_int16, N*L*M, []));
    spCubeIQ_int16(1:2:end) = i;
    spCubeIQ_int16(2:2:end) = q;
    tag = simStep*(k-1);
    fileName  = strcat("./Cuboids/cuboid_", num2str(tag), "x", "cpi.bin");
    fileID    = fopen(fileName,'w');
    fwrite(fileID, spCubeIQ_int16, 'int16');
    fclose(fileID);
    
    %% Determine the increment in covered distance for the radar-platform,
    %  the moving-target and the jammer
    simParam(k) = paramSTAP;   % keep a copy of updated parameters in simParam
    % simParam(1) is equal to paramSTAP before entering the loop
    
    % Determine the covered distance by radar w.r.t. the initial reference
    rDeltaX = rDeltaX + rSpeed(1)*simStep*cpi;
    rDeltaY = rDeltaY + rSpeed(2)*simStep*cpi;
    rDeltaZ = rDeltaZ + rSpeed(3)*simStep*cpi;
    
    % Determine the covered distance by jammer w.r.t. the initial reference
    jDeltaX = jDeltaX + jSpeed(1)*simStep*cpi;
    jDeltaY = jDeltaY + jSpeed(2)*simStep*cpi;
    jDeltaZ = jDeltaZ + jSpeed(3)*simStep*cpi;
    
    % Determine the covered distance by target w.r.t. the initial reference
    tDeltaX = tDeltaX + tSpeed(1)*simStep*cpi;
    tDeltaY = tDeltaY + tSpeed(2)*simStep*cpi;
end
close_system('xRadar.slx');

